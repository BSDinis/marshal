#!/usr/bin/env python3
""" Marshal Compiler """

import sys
import re

cin = sys.stdin;



def scan():
    def rem_comments(text):
        """ remove the comments from text """
        def rem_c_comments(text):
            begin_comment_idx = list();
            last_comment_idx = list();
            stripped = str();
            nest = 0
            for idx, ch in enumerate(text):
                if text[idx: idx + 2] == '/*':
                    begin_comment_idx.append(idx);
                    nest += 1
                elif text[idx: idx + 2] == '*/':
                    if nest == 1:
                        last_comment_idx.append(idx + 2);
                    else:
                        begin_comment_idx.pop();
                    nest -= 1

            base = 0

            for i in range(len(last_comment_idx)):
                stripped += text[base: begin_comment_idx[i]];
                base = last_comment_idx[i] + 1;

            return stripped + text[base:];

        def rem_line_comments(text):
            return re.sub('//.*', '', text);

        return rem_line_comments(rem_c_comments(text));

    def group_braces(tokens):
        grouped = list();
        begin_brace = list();
        last_brace = list();
        curr_list = list();
        for tok in tokens:
            #print(f"tok: {tok} | grouped: {grouped} | curr_list: {curr_list}")
            if tok == '}':
                grouped += [curr_list];
                curr_list = grouped;
            elif tok == '{':
                grouped += curr_list
                curr_list = list();
            else:
                curr_list += [tok]


        return grouped + curr_list;

    def make_sentences(lists):
        sentences = list();
        sentence = list();
        for el in lists:
            if type(el) == list:
                sentence += [make_sentences(el)]
            else:
                if el == ';':
                    sentences += [sentence];
                    sentence = list();
                else:
                    sentence += [el];

        return sentences

    text = rem_comments(cin.read()).replace('\n', '');
    text = text.replace('}', ' } ');
    text = text.replace('{', ' { ');
    text = text.replace(',', ' , ');
    text = text.replace(';', ' ; ');
    sentences = text.split(' ')
    sentences = [s for s in sentences if s != '']
    return make_sentences(group_braces(sentences));

def compile_stmt(stmt):
    def compile_basic_stmt(stmt):
        if stmt[0] == 'typedef':
            return ' '.join(stmt) + ';\n\n', '';

        typename_ = '_'.join(stmt);
        typename = ' '.join(stmt);
        header  = '// adds the corresponding bytes to the buffer, advancing the pointer; fails if there isn\'t enough space\n'
        header += 'int marshall_{t_}(uint8_t ** ptr, ssize_t * rem, {t} val);\n\n'.format(t_ = typename_, t=typename);
        header += '// rems the corresponding bytes from the buffer, advancing the pointer; fails if there isn\'t enough space; stores result in *val\n'
        header += 'int unmarshall_{t_}(uint8_t ** ptr, ssize_t * rem, {t} * val);\n\n'.format(t_ = typename_, t = typename)

        code    = '// adds the corresponding bytes to the buffer, advancing the pointer; fails if there isn\'t enough space\n'
        code   += 'int marshall_{t_}(uint8_t ** ptr, ssize_t * rem, {t} val)\n'.format(t_ = typename_, t = typename)
        code   += '{\n'
        code   += '  if (ptr == NULL) return 1;\n'
        code   += '  if (rem && *rem < sizeof({t})) return -1;\n'.format(t = typename)
        code   += '  memcpy(*ptr, &val, sizeof({t}));\n'.format(t = typename)
        code   += '  *ptr += sizeof({t});\n'.format(t = typename)
        code   += '  if (rem) *rem -= sizeof({t});\n'.format(t = typename)
        code   += '  return 0;\n'
        code   += '}\n\n'
        code   += '// rems the corresponding bytes from the buffer, advancing the pointer; fails if there isn\'t enough space; stores result in *val\n'
        code   += 'int unmarshall_{t_}(uint8_t ** ptr, ssize_t * rem, {t} * val)\n'.format(t_ = typename_, t = typename)
        code   += '{\n'
        code   += '  if (ptr == NULL) return 1;\n'
        code   += '  if (rem && *rem < sizeof({t})) return -1;\n'.format(t = typename)
        code   += '  memcpy(&val, *ptr, sizeof({t}));\n'.format(t = typename)
        code   += '  *ptr += sizeof({t});\n'.format(t = typename)
        code   += '  if (rem) *rem -= sizeof({t});\n'.format(t = typename)
        code   += '  return 0;\n'
        code   += '}\n\n'

        return (header, code);

    def compile_struct(stmt):
        header = str();
        if stmt[0] != 'typedef': header += 'typedef ';
        for top_level in stmt:
            if isinstance(top_level, list):
                header += '\n{\n';
                for sub_stmt in top_level:
                    header += '  ' + ' '.join(sub_stmt) + ';\n';
                header += '}';
            else:
                header += top_level + ' ';
        if stmt[0] != 'typedef':
            header += ' ';
            state = 0
            for top_level in stmt:
                if state == 0:
                    if top_level == 'struct': state = 1
                else:
                    if isinstance(top_level, list): break;
                    else: header += top_level + ' ';
        header += ';\n';
        return header, '';

    def compile_compound_stmt(stmt):
        if stmt[0] == 'struct' or stmt[0] == 'typedef':
            return compile_struct(stmt)
        pass


    if any(isinstance(i, list) for i in stmt):
        return compile_compound_stmt(stmt);
    else:
        return compile_basic_stmt(stmt);


def main():
    """ main compiler routine """
    stmts = scan();
    print(stmts)
    header = '// these are the headers\n\n'
    code   = '// this is the implementation\n\n'
    for stmt in stmts:
        (a, b) = compile_stmt(stmt);
        header += a;
        code += b;

    print(header);
    print('/* =============================== */\n\n')
    print(code);
    return 0;

if __name__ == '__main__':
    sys.exit(main());

