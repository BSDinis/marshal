#!/usr/bin/env python3
""" Marshal Compiler """

import sys
import re

cin = sys.stdin;



def scan():
    def rem_comments(text):
        """ remove the comments from text """
        def rem_c_comments(text):
            begin_comment_idx = list();
            last_comment_idx = list();
            stripped = str();
            nest = 0
            for idx, ch in enumerate(text):
                if text[idx: idx + 2] == '/*':
                    begin_comment_idx.append(idx);
                    nest += 1
                elif text[idx: idx + 2] == '*/':
                    if nest == 1:
                        last_comment_idx.append(idx + 2);
                    else:
                        begin_comment_idx.pop();
                    nest -= 1

            base = 0

            for i in range(len(last_comment_idx)):
                stripped += text[base: begin_comment_idx[i]];
                base = last_comment_idx[i] + 1;

            return stripped + text[base:];

        def rem_line_comments(text):
            return re.sub('//.*', '', text);

        return rem_line_comments(rem_c_comments(text));

    def group_braces(tokens):
        grouped = list();
        begin_brace = list();
        last_brace = list();
        curr_list = list();
        for tok in tokens:
            if tok == '}':
                grouped += [curr_list];
                curr_list = [];
            elif tok == '{':
                grouped += curr_list
                curr_list = [];
            else:
                curr_list += [tok];

        if curr_list: grouped += curr_list
        return grouped;

    def make_sentences(lists):
        sentences = list();
        sentence = list();
        for el in lists:
            if isinstance(el, list):
                sentence += [make_sentences(el)]
            else:
                if el == ';':
                    sentences += [sentence];
                    sentence = list();
                else:
                    sentence += [el];

        return sentences

    text = rem_comments(cin.read()).replace('\n', '');
    text = text.replace('}', ' } ');
    text = text.replace('{', ' { ');
    text = text.replace(',', ' , ');
    text = text.replace(';', ' ; ');
    sentences = text.split(' ')
    sentences = [s for s in sentences if s != '']
    sentences = group_braces(sentences);
    return make_sentences(sentences);

def compile_stmt(stmt):
    def compile_basic_stmt(stmt):
        if stmt[0] == 'typedef':
            return ' '.join(stmt) + ';\n\n', '';

        typename_ = '_'.join(stmt);
        typename = ' '.join(stmt);
        header  = '// adds the corresponding bytes to the buffer, advancing the pointer; fails if there isn\'t enough space\n'
        header += 'int marshall_{t_}(uint8_t ** ptr, ssize_t * rem, {t} val);\n\n'.format(t_ = typename_, t=typename);
        header += '// rems the corresponding bytes from the buffer, advancing the pointer; fails if there isn\'t enough space; stores result in *val\n'
        header += 'int unmarshall_{t_}(uint8_t ** ptr, ssize_t * rem, {t} * val);\n\n'.format(t_ = typename_, t = typename)

        code    = '// adds the corresponding bytes to the buffer, advancing the pointer; fails if there isn\'t enough space\n'
        code   += 'int marshall_{t_}(uint8_t ** ptr, ssize_t * rem, {t} val)\n'.format(t_ = typename_, t = typename)
        code   += '{\n'
        code   += '  if (ptr == NULL) return 1;\n'
        code   += '  if (rem && *rem < sizeof({t})) return -1;\n'.format(t = typename)
        code   += '  memcpy(*ptr, &val, sizeof({t}));\n'.format(t = typename)
        code   += '  *ptr += sizeof({t});\n'.format(t = typename)
        code   += '  if (rem) *rem -= sizeof({t});\n'.format(t = typename)
        code   += '  return 0;\n'
        code   += '}\n\n'
        code   += '// rems the corresponding bytes from the buffer, advancing the pointer; fails if there isn\'t enough space; stores result in *val\n'
        code   += 'int unmarshall_{t_}(uint8_t ** ptr, ssize_t * rem, {t} * val)\n'.format(t_ = typename_, t = typename)
        code   += '{\n'
        code   += '  if (ptr == NULL) return 1;\n'
        code   += '  if (rem && *rem < sizeof({t})) return -1;\n'.format(t = typename)
        code   += '  memcpy(&val, *ptr, sizeof({t}));\n'.format(t = typename)
        code   += '  *ptr += sizeof({t});\n'.format(t = typename)
        code   += '  if (rem) *rem -= sizeof({t});\n'.format(t = typename)
        code   += '  return 0;\n'
        code   += '}\n\n'

        return (header, code);

    def compile_struct(stmt):
        def analyse_struct(stmt):
            struct = dict();
            offset = 0;
            if stmt[0] == 'typedef':
                offset += 1
                if isinstance(stmt[-1], str):
                    struct['typedef'] = stmt[-1]
                else:
                    raise SyntaxError(stmt[-1] + " must be a string to name a type");

            if stmt[offset] != 'struct':
                raise SyntaxError("invalid construct");
            if not isinstance(stmt[offset+1], str):
                raise SyntaxError(stmt[offset+1] + " does not name a type");
            if not isinstance(stmt[offset+2], list):
                raise SyntaxError(stmt[offset+2] + " must be a list");

            struct['struct'] = stmt[offset+1]
            if 'typedef' not in struct:
                struct['typedef'] = struct['struct'];

            members = list();
            for sub_stmt in stmt[offset+2]:
                if any(not isinstance(i, str) for i in sub_stmt):
                    raise SyntaxError('All elements of the statement must be strings');
                if len(sub_stmt) < 2:
                    raise SyntaxError('Should have at least two');

                typename = sub_stmt[0];
                for name in sub_stmt[1:]:
                    if name == ',':
                        continue
                    if any(pair[1] == name for pair in members):
                        raise SyntaxError('Duplicate member named ' + name);

                    members.append((typename, name));

            struct['members'] = members;
            return struct;

        struct = analyse_struct(stmt);
        header = 'typedef ' + struct['struct'] + '\n{\n';
        for member in struct['members']:
            header += '  ' + member[0] + ' ' + member[1] + ';\n';
        header += '} ' + struct['typedef'] + ';\n';

        return header, '';

    def compile_compound_stmt(stmt):
        if stmt[0] == 'struct' or stmt[0] == 'typedef':
            return compile_struct(stmt)
        pass

    if any(isinstance(i, list) for i in stmt):
        return compile_compound_stmt(stmt);
    else:
        return compile_basic_stmt(stmt);


def main():
    """ main compiler routine """
    stmts = scan();
    header = '// these are the headers\n\n'
    code   = '// this is the implementation\n\n'
    for stmt in stmts:
        (a, b) = compile_stmt(stmt);
        header += a;
        code += b;

    print(header);
    print('/* =============================== */\n\n')
    print(code);
    return 0;

if __name__ == '__main__':
    sys.exit(main());

